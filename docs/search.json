[
  {
    "objectID": "src/mlops_ods/notebooks/eda.html",
    "href": "src/mlops_ods/notebooks/eda.html",
    "title": "NY 2015 street tree data EDA",
    "section": "",
    "text": "Code\nimport os\n\nimport folium\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom folium import Circle, Marker\n\n\n\nData\nhttps://www.kaggle.com/datasets/new-york-city/ny-2015-street-tree-census-tree-data\nStreet tree data 2015. Tree data collected includes tree species, diameter and perception of health.\n\n\nCode\ndef download_kaggle_dataset_if_not_exist(path_to_data_folder: str,\n                                         file_name_with_data: str) -&gt; None:\n    \"\"\"\n    Download dataset from kaggle if it's not already exists in path_to_data folder with file_name name\n\n    :param path_to_data_folder: path to folder with data\n    :param file_name_with_data: name of file with data\n    :return: None\n    \"\"\"\n    # Check if the file exists in the folder\n    file_path = os.path.join(path_to_data_folder, file_name_with_data)\n    if not os.path.exists(file_path):\n        # If not, download it\n        try:\n            !kaggle datasets download -d new-york-city/ny-2015-street-tree-census-tree-data -p $path_to_data --unzip\n            print(f\"Downloaded {file_name_with_data} from Kaggle\")\n        except Exception as e:\n            print(f\"Error downloading {file_name_with_data}: {str(e)}\")\n    else:\n        print(f\"{file_name_with_data} already exists\")\n\n\n\n\nCode\npath_to_data = os.path.join(os.path.dirname(os.getcwd()), 'dataset')\nfile_name = '2015-street-tree-census-tree-data.csv'\ndownload_kaggle_dataset_if_not_exist(path_to_data, file_name)\n\n\n2015-street-tree-census-tree-data.csv already exists\n\n\n\n\nEDA\n\n\nCode\ndf = pd.read_csv(f\"{path_to_data}/{file_name}\")\n\n\n\n\nCode\ndf.head()\n\n\n\n\n\n\n\n\n\n\ntree_id\nblock_id\ncreated_at\ntree_dbh\nstump_diam\ncurb_loc\nstatus\nhealth\nspc_latin\nspc_common\n...\nboro_ct\nstate\nlatitude\nlongitude\nx_sp\ny_sp\ncouncil district\ncensus tract\nbin\nbbl\n\n\n\n\n0\n180683\n348711\n2015-08-27T00:00:00.000\n3\n0\nOnCurb\nAlive\nFair\nAcer rubrum\nred maple\n...\n4073900\nNew York\n40.723092\n-73.844215\n1027431.148\n202756.7687\n29.0\n739.0\n4052307.0\n4.022210e+09\n\n\n1\n200540\n315986\n2015-09-03T00:00:00.000\n21\n0\nOnCurb\nAlive\nFair\nQuercus palustris\npin oak\n...\n4097300\nNew York\n40.794111\n-73.818679\n1034455.701\n228644.8374\n19.0\n973.0\n4101931.0\n4.044750e+09\n\n\n2\n204026\n218365\n2015-09-05T00:00:00.000\n3\n0\nOnCurb\nAlive\nGood\nGleditsia triacanthos var. inermis\nhoneylocust\n...\n3044900\nNew York\n40.717581\n-73.936608\n1001822.831\n200716.8913\n34.0\n449.0\n3338310.0\n3.028870e+09\n\n\n3\n204337\n217969\n2015-09-05T00:00:00.000\n10\n0\nOnCurb\nAlive\nGood\nGleditsia triacanthos var. inermis\nhoneylocust\n...\n3044900\nNew York\n40.713537\n-73.934456\n1002420.358\n199244.2531\n34.0\n449.0\n3338342.0\n3.029250e+09\n\n\n4\n189565\n223043\n2015-08-30T00:00:00.000\n21\n0\nOnCurb\nAlive\nGood\nTilia americana\nAmerican linden\n...\n3016500\nNew York\n40.666778\n-73.975979\n990913.775\n182202.4260\n39.0\n165.0\n3025654.0\n3.010850e+09\n\n\n\n\n5 rows × 45 columns\n\n\n\n\n\n\nCode\ndf.describe()\n\n\n\n\n\n\n\n\n\n\ntree_id\nblock_id\ntree_dbh\nstump_diam\npostcode\ncommunity board\nborocode\ncncldist\nst_assem\nst_senate\nboro_ct\nlatitude\nlongitude\nx_sp\ny_sp\ncouncil district\ncensus tract\nbin\nbbl\n\n\n\n\ncount\n683788.000000\n683788.000000\n683788.000000\n683788.000000\n683788.000000\n683788.000000\n683788.000000\n683788.000000\n683788.000000\n683788.000000\n6.837880e+05\n683788.000000\n683788.000000\n6.837880e+05\n683788.000000\n677269.000000\n677269.000000\n6.742290e+05\n6.742290e+05\n\n\nmean\n365205.011085\n313793.096236\n11.279787\n0.432463\n10916.246044\n343.505404\n3.358500\n29.943181\n50.791583\n20.615781\n3.404914e+06\n40.701261\n-73.924060\n1.005280e+06\n194798.424625\n30.027330\n11957.368422\n3.495439e+06\n3.413414e+09\n\n\nstd\n208122.092902\n114839.024312\n8.723042\n3.290241\n651.553364\n115.740601\n1.166746\n14.328531\n18.966520\n7.390844\n1.175863e+06\n0.090311\n0.123583\n3.428505e+04\n32902.061114\n14.301717\n30745.739811\n1.193275e+06\n1.174892e+09\n\n\nmin\n3.000000\n100002.000000\n0.000000\n0.000000\n83.000000\n101.000000\n1.000000\n1.000000\n23.000000\n10.000000\n1.000201e+06\n40.498466\n-74.254965\n9.133493e+05\n120973.792200\n1.000000\n1.000000\n1.000000e+06\n0.000000e+00\n\n\n25%\n186582.750000\n221556.000000\n4.000000\n0.000000\n10451.000000\n302.000000\n3.000000\n19.000000\n33.000000\n14.000000\n3.011700e+06\n40.631928\n-73.980500\n9.896578e+05\n169515.153700\n19.000000\n202.000000\n3.031991e+06\n3.011240e+09\n\n\n50%\n366214.500000\n319967.000000\n9.000000\n0.000000\n11214.000000\n402.000000\n4.000000\n30.000000\n52.000000\n21.000000\n4.008100e+06\n40.700612\n-73.912911\n1.008386e+06\n194560.252500\n30.000000\n516.000000\n4.020352e+06\n4.008560e+09\n\n\n75%\n546170.250000\n404624.000000\n16.000000\n0.000000\n11365.000000\n412.000000\n4.000000\n43.000000\n64.000000\n25.000000\n4.103202e+06\n40.762228\n-73.834910\n1.029991e+06\n217019.571950\n43.000000\n1417.000000\n4.263123e+06\n4.105700e+09\n\n\nmax\n722694.000000\n999999.000000\n450.000000\n140.000000\n11697.000000\n503.000000\n5.000000\n51.000000\n87.000000\n36.000000\n5.032300e+06\n40.912918\n-73.700488\n1.067248e+06\n271894.092100\n51.000000\n157903.000000\n5.515124e+06\n5.080500e+09\n\n\n\n\n\n\n\n\n\n\nCode\ndf.info()\n\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 683788 entries, 0 to 683787\nData columns (total 45 columns):\n #   Column            Non-Null Count   Dtype  \n---  ------            --------------   -----  \n 0   tree_id           683788 non-null  int64  \n 1   block_id          683788 non-null  int64  \n 2   created_at        683788 non-null  object \n 3   tree_dbh          683788 non-null  int64  \n 4   stump_diam        683788 non-null  int64  \n 5   curb_loc          683788 non-null  object \n 6   status            683788 non-null  object \n 7   health            652172 non-null  object \n 8   spc_latin         652169 non-null  object \n 9   spc_common        652169 non-null  object \n 10  steward           164350 non-null  object \n 11  guards            79866 non-null   object \n 12  sidewalk          652172 non-null  object \n 13  user_type         683788 non-null  object \n 14  problems          225844 non-null  object \n 15  root_stone        683788 non-null  object \n 16  root_grate        683788 non-null  object \n 17  root_other        683788 non-null  object \n 18  trunk_wire        683788 non-null  object \n 19  trnk_light        683788 non-null  object \n 20  trnk_other        683788 non-null  object \n 21  brch_light        683788 non-null  object \n 22  brch_shoe         683788 non-null  object \n 23  brch_other        683788 non-null  object \n 24  address           683788 non-null  object \n 25  postcode          683788 non-null  int64  \n 26  zip_city          683788 non-null  object \n 27  community board   683788 non-null  int64  \n 28  borocode          683788 non-null  int64  \n 29  borough           683788 non-null  object \n 30  cncldist          683788 non-null  int64  \n 31  st_assem          683788 non-null  int64  \n 32  st_senate         683788 non-null  int64  \n 33  nta               683788 non-null  object \n 34  nta_name          683788 non-null  object \n 35  boro_ct           683788 non-null  int64  \n 36  state             683788 non-null  object \n 37  latitude          683788 non-null  float64\n 38  longitude         683788 non-null  float64\n 39  x_sp              683788 non-null  float64\n 40  y_sp              683788 non-null  float64\n 41  council district  677269 non-null  float64\n 42  census tract      677269 non-null  float64\n 43  bin               674229 non-null  float64\n 44  bbl               674229 non-null  float64\ndtypes: float64(8), int64(11), object(26)\nmemory usage: 234.8+ MB\n\n\n\n\nCode\ndf.shape\n\n\n(683788, 45)\n\n\n\nreplace object data to other types\nmany data in object format, let’s see what we can do with it\n\n\nCode\ndf['created_at'] = pd.to_datetime(df['created_at'])\n\n\n\n\nCode\ndf['curb_loc'].value_counts()\n\n\ncurb_loc\nOnCurb            656896\nOffsetFromCurb     26892\nName: count, dtype: int64\n\n\nwe can replace this with binary feature: - 1: OnCurb - 0: OffsetFromCurb\n\n\nCode\ndf['curb_loc'] = (df['curb_loc'] == 'OnCurb') * 1\n\n\n\n\nCode\ndf['sidewalk'].value_counts(dropna=False)\n\n\nsidewalk\nNoDamage    464978\nDamage      187194\nNaN          31616\nName: count, dtype: int64\n\n\nwe can replace this with binary feature: - 1: Damage - 0: NoDamage\n\n\nCode\ndf['sidewalk'] = np.where(df['sidewalk'] == 'Damage', 1,\n                          np.where(df['sidewalk'] == 'NoDamage', 0, np.nan))\n\n\nFeatures that we can replace this with binary feature: - 1: Yes - 0: No\n\n\nCode\ndf['root_stone'].value_counts(dropna=False)\n\n\nroot_stone\nNo     543789\nYes    139999\nName: count, dtype: int64\n\n\n\n\nCode\ndf['root_stone'] = (df['root_stone'] == 'Yes') * 1\n\n\n\n\nCode\ndf['root_grate'].value_counts(dropna=False)\n\n\nroot_grate\nNo     680252\nYes      3536\nName: count, dtype: int64\n\n\n\n\nCode\ndf['root_grate'] = (df['root_grate'] == 'Yes') * 1\n\n\n\n\nCode\ndf['root_other'].value_counts(dropna=False)\n\n\nroot_other\nNo     653466\nYes     30322\nName: count, dtype: int64\n\n\n\n\nCode\ndf['root_other'] = (df['root_other'] == 'Yes') * 1\n\n\n\n\nCode\ndf['trunk_wire'].value_counts(dropna=False)\n\n\ntrunk_wire\nNo     670514\nYes     13274\nName: count, dtype: int64\n\n\n\n\nCode\ndf['trunk_wire'] = (df['trunk_wire'] == 'Yes') * 1\n\n\n\n\nCode\ndf['trnk_light'].value_counts(dropna=False)\n\n\ntrnk_light\nNo     682757\nYes      1031\nName: count, dtype: int64\n\n\n\n\nCode\ndf['trnk_light'] = (df['trnk_light'] == 'Yes') * 1\n\n\n\n\nCode\ndf['trnk_other'].value_counts(dropna=False)\n\n\ntrnk_other\nNo     651215\nYes     32573\nName: count, dtype: int64\n\n\n\n\nCode\ndf['trnk_other'] = (df['trnk_other'] == 'Yes') * 1\n\n\n\n\nCode\ndf['brch_light'].value_counts(dropna=False)\n\n\nbrch_light\nNo     621423\nYes     62365\nName: count, dtype: int64\n\n\n\n\nCode\ndf['brch_light'] = (df['brch_light'] == 'Yes') * 1\n\n\n\n\nCode\ndf['brch_shoe'].value_counts(dropna=False)\n\n\nbrch_shoe\nNo     683377\nYes       411\nName: count, dtype: int64\n\n\n\n\nCode\ndf['brch_shoe'] = (df['brch_shoe'] == 'Yes') * 1\n\n\n\n\nCode\ndf['brch_other'].value_counts(dropna=False)\n\n\nbrch_other\nNo     659433\nYes     24355\nName: count, dtype: int64\n\n\n\n\nCode\ndf['brch_other'] = (df['brch_other'] == 'Yes') * 1\n\n\nOther features:\n\n\nCode\ndf['state'].value_counts(dropna=False)\n\n\nstate\nNew York    683788\nName: count, dtype: int64\n\n\nwe can drop this feature because it’s not informative\n\n\nCode\ndf.drop(['state'], axis=1, inplace=True)\n\n\n\n\nmissing values\nwe have some columns with missing values\n\n\nCode\nmissing_percentages = (df.isnull().mean() * 100).round(2)\nmissing_columns = missing_percentages[missing_percentages &gt; 0]\n\n\n\n\nCode\nplt.figure(figsize=(8, 6))\nplt.title('Percentage of Missing Values in Columns')\nsns.barplot(x=missing_columns.index, y=missing_columns.values, palette='viridis', hue=missing_columns.index)\nplt.ylabel('Percentage of Missing Values')\nplt.xlabel('Columns')\nplt.xticks(rotation=45)\nfor index, value in enumerate(missing_columns):\n    plt.text(index, value, f'{value}%', ha='center', va='bottom')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\ndf[['steward', 'guards', 'problems']].dropna().head()\n\n\n\n\n\n\n\n\n\n\nsteward\nguards\nproblems\n\n\n\n\n13\n3or4\nHarmful\nRootOther\n\n\n19\n1or2\nHelpful\nStones\n\n\n21\n1or2\nUnsure\nRootOther,TrunkOther,BranchOther\n\n\n26\n1or2\nHelpful\nStones,BranchLights\n\n\n32\n1or2\nUnsure\nMetalGrates,TrunkOther\n\n\n\n\n\n\n\n\nThe most missing values from steward, guards and problems. Seems that this data was really hard to collect.\n\n\ndistribution of features\n\n\nCode\ncat_cols = ['status', 'health', 'spc_latin', 'spc_common', 'steward',\n            'guards', 'user_type', 'problems', 'address', 'zip_city', \n            'borough','nta', 'nta_name']\nnum_cols = ['tree_id', 'block_id','tree_dbh', 'stump_diam','curb_loc',\n            'sidewalk','root_stone','root_grate', 'root_other', 'trunk_wire', \n            'trnk_light', 'trnk_other','brch_light', 'brch_shoe', 'brch_other',\n            'postcode','community board', 'borocode','cncldist','st_assem', \n            'st_senate','boro_ct','latitude','longitude', 'x_sp', 'y_sp', 'council district', \n            'census tract', 'bin','bbl']\nother_cols = ['created_at',]\n\n\nlet’s look at the distribution of numerical features\n\n\nCode\ndf[num_cols].hist(figsize=(20, 20));\n\n\n\n\n\n\n\n\n\nInsights:\n- ‘tree_dbh’: Diameter at breast height of tree can have rare big values - ‘stump_diam’: Diameter of stump can have rare big values, a lot of values is 0 - ‘curb_loc’: most trees are along the curb - ‘root_grate’: there are small amount of root problems caused by metal grates - ‘root_other’: there are small amount of other root problems - ‘trunk_wire’: there are small amount of any trunk problems - ‘brch_light’: there are small amount of any branch problems\nlet’s look at the distribution of date features\n\n\nCode\nplt.figure(figsize=(200, 30))\ndf['created_at'].value_counts().sort_index().plot(kind='bar')\nplt.tight_layout();\n\n\n\n\n\n\n\n\n\n\n\nCode\ndf['created_at'].describe()\n\n\ncount                           683788\nmean     2015-12-06 07:18:59.574254592\nmin                2015-05-19 00:00:00\n25%                2015-08-29 00:00:00\n50%                2015-10-23 00:00:00\n75%                2016-02-06 00:00:00\nmax                2016-10-05 00:00:00\nName: created_at, dtype: object\n\n\ndata from May 2015 till october 2016 with small amount of values from 01-2016 to 04-2016\nlet’s look at the distribution of categorical features (draw only features with small amount of values)\n\n\nCode\ndraw_cols = ['status','health','steward','guards','user_type','borough',]\n\n\n\n\nCode\nplt.figure(figsize=(20, 10)) \n\nfor i, col in enumerate(draw_cols, 1):\n    plt.subplot(3, 3, i)\n    sns.countplot(x=col, data=df)\n    plt.xlabel(col)\n    plt.ylabel('Count')\n    plt.title(f'Count Plot of {col}')\n\n\nplt.tight_layout()\n\nplt.show()\n\n\n\n\n\n\n\n\n\nInsights: - most problems is stones - most data from Brooklyn - most trees alive with good health, 1 or 2 stewards, with helpful guards\n\n\npairwise distribution\ndraw pairplots for interesting columns (for all columns it’s too long and not informative for geocoded columns)\n\n‘tree_dbh’: Diameter at breast height of tree\n‘stump_diam’: Diameter of stump\n‘curb_loc’: trees are along the curb or not\n‘status’: tree is alive, standing dead, or a stump\n‘health’: tree health\n‘spc_common’: Common name for species\n‘steward’: Number of signs of stewardship observed\n‘guards’: type of tree guard\n‘sidewalk’: Sidewalk damage\n‘user_type’: Category of user who collected this tree point\n‘problems’\n‘root_stone’: Root problems caused by paving stones in the tree bed\n‘root_grate’: Root problems caused by metal grates\n‘root_other’: other root problems\n‘trunk_wire’: Trunk problems caused by rope or wires\n‘trnk_light’: Trunk problems caused by lights\n‘trnk_other’: other trunk problems\n‘brch_light’: Branch problems caused by lights or wires\n‘brch_shoe’: Branch problems caused by shoes\n‘brch_other’: other branch problems\n‘zip_city’\n‘borough’\n\nLet’s look connection of tree status by borough:\n\n\nCode\nfig, axs = plt.subplots(1, 2, figsize=(12, 5))\n\nax1 = sns.countplot(x='borough', hue='status', data=df, ax=axs[0])\ntotal1 = float(len(df))\nfor p in ax1.patches:\n    height = p.get_height()\n    ax1.text(p.get_x() + p.get_width() / 2., height + 3, '{:.1f}%'.format((height / total1) * 100), ha=\"center\")\naxs[0].set_title('Status')\n\nax2 = sns.countplot(x='borough', hue='health', data=df, ax=axs[1])\ntotal2 = float(len(df))\nfor p in ax2.patches:\n    height = p.get_height()\n    ax2.text(p.get_x() + p.get_width() / 2., height + 3, '{:.1f}%'.format((height / total2) * 100), ha=\"center\")\naxs[1].set_title('Health')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nDistribution of good and bad trees has similar trends as total amount of them by each borough. Seems that all boroughs were tried to serve well the trees in area.\nLet’s look at different problems by boroughs:\n\n\nCode\nhue_columns = ['root_stone','root_grate', 'root_other', \n               'trunk_wire', 'trnk_light', 'trnk_other',\n               'brch_light', 'brch_shoe', 'brch_other']\n\nfig, axs = plt.subplots(3, 3, figsize=(20, 15))\naxs = axs.flatten()\n\nfor i, hue_col in enumerate(hue_columns):\n    ax = axs[i]\n    sns.countplot(x='borough', hue=hue_col, data=df, ax=ax)\n    total = float(len(df))\n    for p in ax.patches:\n        height = p.get_height()\n        ax.text(p.get_x() + p.get_width() / 2., height + 3, '{:.1f}%'.format((height / total) * 100), ha=\"center\")\n    \n    ax.set_title(hue_col)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nThere are a lot of problems with stones, trunks and branches in Brooklyn and Queens, problems with metal grates in Manhattan, but small amount of problems with branch.\nLet’s look at connections of diameter of tree, and it’s health:\n\n\nCode\nsns.boxplot(x='health', y='tree_dbh', data=df, showfliers=False);\n\n\n\n\n\n\n\n\n\nwe can notice that than less diameter of tree than less health tree has\nLet’s look on top species with good and bad health:\n\n\nCode\ntmp = df.groupby(['spc_common', 'health']).size().reset_index()\ntmp2 = tmp.groupby(['spc_common'])[0].sum().reset_index()\ntmp2.columns = ['spc_common', 'sum']\ntmp = tmp.merge(tmp2, on=['spc_common'])\ntmp['mean'] = tmp[0] / tmp['sum']\n\ntop10 = tmp[tmp['health'] == 'Good'].sort_values('mean').tail(10)\nbot10 = tmp[tmp['health'] == 'Poor'].sort_values('mean').tail(10)\n\n\n\n\nCode\nfig, axs = plt.subplots(2, 1, figsize=(7, 7))\n\ntop10[['spc_common','mean']].plot(kind='bar', x='spc_common', ax=axs[0], legend=False)\naxs[0].set_title('Top 10 spc_common by mean value')\n\nbot10[['spc_common','mean']].plot(kind='bar', x='spc_common', ax=axs[1], legend=False)\naxs[1].set_title('Bottom 10 spc_common by mean value')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nThe most mean value of the healthiest trees is pitch pine and the smallest mean value of the healthiest trees is maple.\n\n\ncorrelations\n\n\nCode\nplt.figure(figsize=(20, 20)) \ncorr_matrix = df[num_cols].corr().fillna(0)\nsns.heatmap(corr_matrix, annot=True, fmt=\".2f\", cmap='coolwarm', square=True);\n\n\n\n\n\n\n\n\n\nWe can see that diameter at breast height of tree ‘tree_dbh’ has correlation with sidewalk damage and root problems - interesting thing that it’s positive, that mean that than bigger diameter than more problems around tree - maybe because tree was trying to be alive and trees that cannot do that was dead - we can notice that with negative correlation with stump diameter. Also, sidewalk damage and root problems has positive correlation that means that these problems often happen together and sidewalk damage can influence on future root problems. Other root problems and other trunk problems and other branch problems have positive correlation and also can happen together because of union damage from something.\nBranch problems caused by lights or wires ‘brch_light’ have positive correlation with trunk problems caused by rope or wires ‘trunk_wire’, so both of them have problems because of union wires problems.\n\n\ngeo data\n\n\nCode\ndf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df.longitude, df.latitude))\n# Set the coordinate reference system (CRS) to EPSG 4326\ndf.crs = 'epsg:4326'\n\n\n\n\nCode\ndf.plot(markersize=1);\n\n\n\n\n\n\n\n\n\n\n\nCode\n# show 1000 values\nm_2 = folium.Map(location=[40.70,-73.92], zoom_start=11)\n\nfor idx, row in df.head(1000).iterrows():\n    Marker([row['latitude'], row['longitude']]).add_to(m_2)\nm_2\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nLet’s look on location of health and not health trees on the map; values are too much, let’s show random 10000\n\n\nCode\ntmp = df.sample(10000, random_state=42)\n\n\n\n\nCode\nm_4 = folium.Map(location=[40.70,-73.92], tiles='cartodbpositron', zoom_start=11)\n\ndef color_producer(health):\n    if health == 'Good':\n        return 'forestgreen'\n    elif health == 'Fair':\n        return 'darkorange'\n    else:\n        return 'darkred'\n\n# Add a bubble map to the base map\nfor i in range(0,len(tmp)):\n    Circle(\n        location=[tmp.iloc[i]['latitude'], tmp.iloc[i]['longitude']],\n        radius=20,\n        color=color_producer(tmp.iloc[i]['health'])).add_to(m_4)\n\nm_4\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\nWe can notice that trees with bad health can stay close to each other like 3-4 trees with bad health together. And trees with health closer to bad also stayed near the trees with bad health\nWe can say that most trees with bad health or died have combination of different problems around them, like roots, trunks and branches and on this has influence by damaged sidewalks. Most trees are good and healthy in all represented borough in NY. Manhattan and Bronx boroughs has the least amount of trees and the greenest borough is Queens - it’s better to live in this borough if you need to live in NY."
  },
  {
    "objectID": "contributing.html",
    "href": "contributing.html",
    "title": "",
    "section": "",
    "text": "create new brunch from master with one of prefixes (‘fix-’, ‘feature-’, ‘model-’, ‘experiment-’)\nadd changing to files with tests (pytest)\ncheck linters/formatters with pre-commit hooks (scroll down for more info)\nask review for commit to master branch"
  },
  {
    "objectID": "contributing.html#how-to-contribute",
    "href": "contributing.html#how-to-contribute",
    "title": "",
    "section": "",
    "text": "create new brunch from master with one of prefixes (‘fix-’, ‘feature-’, ‘model-’, ‘experiment-’)\nadd changing to files with tests (pytest)\ncheck linters/formatters with pre-commit hooks (scroll down for more info)\nask review for commit to master branch"
  },
  {
    "objectID": "contributing.html#linters-and-formatters",
    "href": "contributing.html#linters-and-formatters",
    "title": "",
    "section": "Linters and formatters",
    "text": "Linters and formatters\nIn project’s used pre-commit hooks which checks following linters/formatters: * flake8 (linter) # poetry run flake8 –exclude=venv . * black (auto formatter) # poetry run black . * isort (import sorting) # poetry run isort . * mypy (type checking) # poetry run mypy –explicit-package-bases –exclude venv .\nalso in project’s used: * pytest (tests) * pre-commit\nfor install pre-commit hooks / install for each commit:\npre-commit autoupdate\npoetry run pre-commit install\npoetry run pre-commit install -t pre-commit\nfor check hooks before commit:\npoetry run pre-commit run --all-files\nall restrictions for linters you can find in pyproject.toml file"
  }
]
